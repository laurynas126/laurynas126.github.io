<!DOCTYPE html>


<html>

<head>
    <title>Labyrinth</title>
    <script type="text/javascript" src="libs/three.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script type="text/javascript" src="libs/TrackballControls.js"></script>
    <script src="https://threejs.org/examples/js/loaders/SVGLoader.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <!-- Div which will hold the Output -->
    <div id="WebGL-output">
    </div>

    <!-- Javascript code that runs our Three.js examples -->
    <script type="text/javascript">

        var svgManager = new THREE.SVGLoader();
        var svgUrl = 'https://klevas.mif.vu.lt/~rimask/geometrija/maze_4.svg';
        var result = null;
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer();
        var clock = new THREE.Clock();

        var cubeFaces = [];
        var exploded = false;



        function buildSVG(svgDocument) {
            console.log("Loaded");
            result = svgDocument;
            var width = Number(result.getAttribute('width')) + 50;
            var height = Number(result.getAttribute('height')) + 50;
            scene.add(getPlane(width / 2 - 25, height / 2 - 25, width, height));
            var walls = result.children[2].children;
            var singleGeometry = new THREE.Geometry();
            for (var index = 0; index < walls.length; index++) {
                var element = walls[index];
                var x = Number(element.getAttribute('x1'));
                var lengthX = Number(element.getAttribute('x2')) - x;
                var z = Number(element.getAttribute('y1'));
                var lengthZ = Number(element.getAttribute('y2')) - z;
                var wall = getWall(x, 5, z, lengthX, 10, lengthZ, 3);
                wall.updateMatrix(); // as needed
                singleGeometry.merge(wall.geometry, wall.matrix);
            }
            var boxMat = new THREE.MeshLambertMaterial({ color: 0xF6831E});
            var mesh = new THREE.Mesh(singleGeometry, boxMat);
            scene.add(mesh);
        }

        function getWall(x, y, z, lenX, lenY, lenZ, thickness){
            if (lenZ == 0) {
                lenY = lenY + 0.1;
                // x += thickness;
                // lenX -= thickness;
                thickness += 0.1;
            }
            x = x + lenX / 2;
            z = z + (thickness + lenZ) / 2;
            var boxGeom = new THREE.BoxGeometry(lenX + thickness,lenY,lenZ + thickness);
            // var boxMat = new THREE.MeshLambertMaterial({ color: 0xF6831E});
            var box = new THREE.Mesh(boxGeom);
            box.position.x = x;
            box.position.y = y;
            box.position.z = z;
            box.castShadow = true;
            return box;
            // scene.add(box);
        }

        function getPlane(x, z, width, height){
            var planeGeometry = new THREE.PlaneGeometry(width, height);
            var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            var plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.receiveShadows = true;

            plane.rotation.x = -0.5 * Math.PI;
            plane.position.x = x
            plane.position.y = 0
            plane.position.z = z

            return plane;
        }

        function getSpotlight(x, y, z){
            var spotLight = new THREE.SpotLight( 0xffffff );
            spotLight.position.set( x, y, z );
            spotLight.castShadow = true;
            // spotLight.distance = 20;
            return spotLight;
        }

        function getTriangle(x, y, z, lengthX, lengthY, lengthZ) {
            var geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3(x + lengthX, y, z));
            geometry.vertices.push(new THREE.Vector3(x, y + lengthY, z));
            geometry.vertices.push(new THREE.Vector3(x, y , z + lengthZ));
            geometry.faces.push(new THREE.Face3(0, 1, 2));
            geometry.computeFaceNormals();
            geometry.computeVertexNormals();
            var material1 = new THREE.MeshLambertMaterial({ color: 0x00A3A3, side: THREE.DoubleSide });
            var triangle = new THREE.Mesh(geometry, material1);
            triangle.castShadow = true;
            return triangle;
        }

        function buildCube(x,y,z, size){
            cubeFaces = [];
            var split = 4;
            var faceLen = size / split;
            for (var index = 0; index < split; index++) {
                for (var j = 0; j < split; j++) {
                    cubeFaces.push(getTriangle(x + faceLen*index,y + j*faceLen, z, faceLen, faceLen, 0));
                    cubeFaces.push(getTriangle(x + faceLen*index + faceLen ,y + j*faceLen + faceLen ,z, -faceLen, -faceLen, 0));

                    cubeFaces.push(getTriangle(x + faceLen*index,y + j*faceLen, z + size, faceLen, faceLen, 0));
                    cubeFaces.push(getTriangle(x + faceLen*index + faceLen ,y + j*faceLen + faceLen ,z + size, -faceLen, -faceLen, 0));

                    cubeFaces.push(getTriangle(x + faceLen*index,y, z  + j*faceLen, faceLen, 0, faceLen));
                    cubeFaces.push(getTriangle(x + faceLen*index + faceLen ,y ,z + j*faceLen + faceLen, -faceLen, 0, -faceLen));

                    cubeFaces.push(getTriangle(x + faceLen*index,y  + size, z  + j*faceLen, faceLen, 0, faceLen));
                    cubeFaces.push(getTriangle(x + faceLen*index + faceLen ,y + size,z + j*faceLen + faceLen, -faceLen, 0, -faceLen));

                    cubeFaces.push(getTriangle(x, y + faceLen*index, z  + j*faceLen, 0, faceLen, faceLen));
                    cubeFaces.push(getTriangle(x, y + faceLen*index + faceLen, z + j*faceLen + faceLen, 0, -faceLen, -faceLen));

                    cubeFaces.push(getTriangle(x  + size, y + faceLen*index, z  + j*faceLen, 0, faceLen, faceLen));
                    cubeFaces.push(getTriangle(x  + size, y + faceLen*index + faceLen, z + j*faceLen + faceLen, 0, -faceLen, -faceLen));
                } 
            }           
            cubeFaces.forEach(function(element) {

                scene.add(element);
            }, this);
        }

        function explodeCube(){
            cubeFaces.forEach(function(element) {
                element.position.x += (Math.random() * 0.2 - 0.1);
                element.position.y += (Math.random() * 0.2 - 0.1);
                element.position.z += (Math.random() * 0.2 - 0.1);
            }, this);
        }


        $(function () {
            renderer.setClearColor(0xEEEEEE);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMapEnabled = true;

            svgManager.load(svgUrl,
                buildSVG,
                function () { console.log("Loading SVG..."); },
                function () { console.log("Error loading SVG!");
            });

            // var axes = new THREE.AxisHelper(20);
            // scene.add(axes);

            buildCube(50,5,74,5);

            camera.position.x = -100;
            camera.position.y = 100;
            camera.position.z = 100;
            camera.lookAt(scene.position);


            var trackballControls = new THREE.TrackballControls(camera);

            trackballControls.rotateSpeed = 1.0;
            trackballControls.zoomSpeed = 1.0;
            trackballControls.panSpeed = 1.0;
            trackballControls.staticMoving = false;

            var ambientLight = new THREE.AmbientLight(0x0c0c0c);
            scene.add(ambientLight);
           
            scene.add(getSpotlight(100, 60, 120));
            scene.add(getSpotlight(150, 10, 150));

            // add the output of the renderer to the html element
            $("#WebGL-output").append(renderer.domElement);

            // render the scene
            render();

            function render() {
                var delta = clock.getDelta();
                trackballControls.update(delta);
                //webGLRenderer.clear();
                // render using requestAnimationFrame
                requestAnimationFrame(render);
                renderer.render(scene, camera);
                if (camera.position.distanceTo(cubeFaces[1].geometry.vertices[0]) < 50){
                    exploded = true;
                }
                if (exploded){
                    explodeCube();
                }
            }
        });



    </script>
</body>

</html>
